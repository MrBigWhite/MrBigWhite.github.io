---
title: "算法进阶之分治"
date: 2025-11-08T12:00:00+08:00
categories:
  - blog
tags:
  - 算法进阶
  - 分治
---
<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']], // 支持 $...$ 行内公式
    displayMath: [['$$', '$$'], ['\\[', '\\]']]
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

1.
# P1177 【模板】排序

## 题目描述

将读入的 $N$ 个数从小到大排序后输出。

## 输入格式

第一行为一个正整数 $N$。

第二行包含 $N$ 个空格隔开的正整数 $a_i$，为你需要进行排序的数。

## 输出格式

将给定的 $N$ 个数从小到大输出，数之间空格隔开，行末换行且无空格。

## 输入输出样例 #1

### 输入 #1

```
5
4 2 4 5 1
```

### 输出 #1

```
1 2 4 4 5
```

## 说明/提示

对于 $20\%$ 的数据，有 $1 \leq N \leq 10^3$；

对于 $100\%$ 的数据，有 $1 \leq N \leq 10^5$，$1 \le a_i \le 10^9$。


解：
```cpp
#include<iostream>
#include<vector>

using namespace std;

void quick_sort(vector<int>& a, int l, int r){
    if(l>=r) return;

    int p=a[(l+r)/2];
    int i=l-1,j=r+1;

    while(i<j){
        do{i++;}while(a[i]<p);
        do{j--;}while(a[j]>p);

        if(i<j){
            swap(a[i], a[j]);
        }
    }
    quick_sort(a, l, j);
    quick_sort(a, j+1, r);
}

int main(){
    int n;
    cin>>n;
    vector<int> a(n,0);

    for(int i=0;i<n;i++){
        cin>>a[i];
    }

    quick_sort(a, 0, n-1);

    for(int i=0;i<n;i++){
        cout<<a[i];
        if(i!=n-1) cout<<" ";
    }

    return 0;
}
```


```cpp
#include<iostream>
#include<vector>

using namespace std;

void merge(vector<int>& a,int l,int m,int r){
    int n1=m-l+1;
    int n2=r-m;
    vector<int> la(n1);
    vector<int> ra(n2);
    for (int i = 0; i < n1; i++) {
        la[i] = a[l + i];
    }
    for (int j = 0; j < n2; j++) {
        ra[j] = a[m + 1 + j];
    }

    int i=0,j=0,k=l;

    while(i<n1&&j<n2){
        if(la[i]<=ra[j]){
            a[k]=la[i];
            i++;
        }
        else{
            a[k]=ra[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        a[k] = la[i];
        i++;
        k++;
    }
    while (j < n2) {
        a[k] = ra[j];
        j++;
        k++;
    }
}

void merge_sort(vector<int>& a,int l,int r){
    if(l<r){
        int m=(l+r)/2;
        merge_sort(a,l,m);
        merge_sort(a,m+1,r);
        merge(a,l,m,r);
    }
} 

int main() {
    int n;
    cin >> n;  
    vector<int> a(n);    
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    
    merge_sort(a, 0, n - 1);
    
    for (int i = 0; i < n; i++) {
        cout << a[i];
        if (i != n - 1) {
            cout << " ";
        }
    }
    cout << endl;
    
    return 0;
}
```


【评】快排（不稳定）和归并（稳定）排序模板，时间复杂度均为$O(nlog n)$。若要直接调用`<algorithm>`库函数，则`sort(vec.begin(), vec.end(), greater<int>());`（降序）。